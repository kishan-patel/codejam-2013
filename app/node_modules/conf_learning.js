var brain = require('brain')
  , https = require('https')
  , server = require('./server.js');

var net = new brain.NeuralNetwork({learningRate:0});
 
function pad(num) {
    norm = Math.abs(Math.floor(num));
    return (norm < 10 ? '0' : '') + norm;
}
function formatLocalDate(date) {
    var local = new Date(date);
    var tzo = -local.getTimezoneOffset();
    var sign = tzo >= 0 ? '+' : '-';
    return local.getFullYear() 
        + '-' + pad(local.getMonth()+1)
        + '-' + pad(local.getDate())
        + 'T' + pad(local.getHours())
        + ':' + pad(local.getMinutes()) 
        + ':' + pad(local.getSeconds()) 
        + sign + pad(tzo / 60) 
        + ':' + pad(tzo % 60);
}

exports.csvForecast = function(data, type){
    return applyMachineLearning(data, type);
}

function applyMachineLearning(data, type){
  //If we are trying to apply the machine learning to the data from the 
  //csv file, then it already contains predictions for weather, temperature etc.
  //so we need to include this when applying machine learning.
 // data.pop();
  var splitData=[], futureData=[], arrays=[];
    splitData = splitPastandFuture(data);
    data = splitData["past"];
    futureData = splitData["future"];
  var size = data.length;  
  var futureScale = [];
  var lower = [];
  var upper = [];
  var mean = [];
  var furLength = futureData.length;
  for(var i = 0;i< furLength;i++){
      /*We have 4 15min intervals in an hour
      *4*24 = 96 in a day
      *and so fourth until we get to last years record for this time
      */
      
      var midPower; 
      var nextSet = [];
      var previousSet = [];
      //console.log(size);
/*      if(size > (34944 + 20 + i)){
          var check = i%34943;
          var lastYearPerdiction = size - 34944 + check;
          midPower = data[lastYearPerdiction]; 
          nextSet = [];
          previousSet = [];
          for(var j = 1;j<20;j++){
            nextSet.push(data[lastYearPerdiction+j]);
            previousSet.push(data[lastYearPerdiction-j]);
          }
      }else*/ if(size>(96+10+i)){
          var check = i%95;
          var lastYearPerdiction = size - 96 +check;
          midPower = data[lastYearPerdiction]; 
          if(midPower == null || midPower == undefined || midPower.power == null || midPower.power == undefined || isNaN(midPower.power)){
            for(var x = 0;x<size;x++){
              var toCheck = (lastYearPerdiction + x)%(size-1)
              if(data[toCheck] == null || data[toCheck] == undefined || data[toCheck].power == null || data[toCheck].power == undefined || isNaN(data[toCheck].power)){

              }else{
                lastYearPerdiction = check;
                midPower = data[toCheck];
                break;
              }
                
            }
          }
          console.log(midPower);
          nextSet = [];
          previousSet = [];
          for(var j = 1;j<10;j++){
          //  console.log(data[lastYearPerdiction+j]);
           // console.log(data[lastYearPerdiction-1]);
          if(lastYearPerdiction-i>=0 && lastYearPerdiction+i<size) {
            nextSet.push(data[lastYearPerdiction+j]);
            previousSet.push(data[lastYearPerdiction-j]);
          }
          }

      }else{
       //dataset is really small so I will just use all points given 
       var midPoint = parseInt(data.length/2);
       midPower = data[midPoint];
       for(var j = 1; j<midPoint;j++){
          if(midPoint-i>=0 && midPoint+i<size){
            nextSet.push(data[midPoint +j]);
            previousSet.push(data[midPoint-j]);
          }
       }
      
      }
    var squaredDiff = [];

    for(var j = 0;j<nextSet.length;j++){
      if(nextSet == null || nextSet == undefined){
        continue;
      }else if(nextSet[j].power == null || nextSet[j].power == undefined || isNaN(nextSet[j].power)){
        continue;
      }
      var diff = nextSet[j].power - midPower.power;
      squaredDiff.push(diff*diff);
    }
    for(var k = 0;k<previousSet.length;k++){
      if(previousSet == null || previousSet == undefined){
        continue;
      }else if(previousSet[k].power == null || previousSet[k].power == undefined || isNaN(previousSet[k].power)){
        continue;
      }
      var diff = previousSet[k].power - midPower.power;
      squaredDiff.push(diff*diff);
    }
    var sqSum = 0;
    if(squaredDiff.length == 0){
        squaredDiff.push(0);
    }
    for(var j=0;j<squaredDiff.length;j++){
      sqSum += squaredDiff[j];
    }

    var deviation =  Math.sqrt(sqSum/squaredDiff.length);
    if(deviation == 0){
      deviation = midPower.power/2;
    }
    var obj = {};
    obj["date"] =  futureData[i].date;
    console.log("Midpower = " +midPower.power +" Dev = "+ deviation);
    obj["mean"] = midPower.power;
    obj["lower-75"] = midPower.power - deviation;
    obj["upper-75"] = midPower.power + deviation;
    futureScale.push(obj); 
   }
    var toPass = {};
    toPass["future"] = futureScale;
    return toPass;
  //console.log(finalDataArray);
}

function splitPastandFuture(data){
  var slicedArr = {};
  for(var i=0; i<data.length; i++){
    if(isNaN(data[i].power)){
      slicedArr.past = data.splice(0,i);
      slicedArr.future = data.splice(i);  
      break;
    }
  }
  return slicedArr;
}

function determineMaxAndMin(arrays){
  var data;
  var minRadiation = 0, maxRadiation = 0,
      minHumidity = 0, maxHumidity = 0,
      minTemperature = 0, maxTemperature = 0,
      minWind = 0, maxWind = 0,
      minPower = 0, maxPower = 0;

  for(var j=0; j<arrays.length; j++){
    data = arrays[j];

    for(var i=0; i<data.length; i++){
      if(!isNaN(data[i].radiation) && data[i].radiation < minRadiation)
        minRadiation = data[i].radiation;

      if(!isNaN(data[i].radiation) && data[i].radiation > maxRadiation)
        maxRadiation = data[i].radiation;

      if(!isNaN(data[i].humidity) && data[i].humidity < minHumidity)
        minHumidity = data[i].humidity;

      if(!isNaN(data[i].humidity) && data[i].humidity > maxHumidity)
        maxHumidity = data[i].humidity;

      if(!isNaN(data[i].temperature) && data[i].temperature < minTemperature)
        minTemperature = data[i].temperature;

      if(!isNaN(data[i].temperature) && data[i].temperature > maxTemperature)
        maxTemperature = data[i].temperature

      if(!isNaN(data[i].wind) && data[i].wind < minWind)
        minWind = data[i].wind;

      if(!isNaN(data[i].wind) && data[i].wind > maxWind)
        maxWind = data[i].wind;

      if(!isNaN(data[i].power) && data[i].power < minPower)
        minPower = data[i].power;

      if(!isNaN(data[i].power) && data[i].power > maxPower)
        maxPower = data[i].power;
    }
  }

  return {
    'minRadiation': minRadiation, 
    'maxRadiation': maxRadiation, 
    'minHumidity': minHumidity,
    'maxHumidity': maxHumidity,
    'minTemperature': minTemperature,
    'maxTemperature': maxTemperature,
    'minWind': minWind,
    'maxWind': maxWind,
    'minPower': minPower,
    'maxPower': maxPower
  }
}
