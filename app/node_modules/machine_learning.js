var brain = require('brain')
  , https = require('https')
  , server = require('./server.js');

var net = new brain.NeuralNetwork({learningRate:0.3});
 
exports.pulseForecast = function(){
  var initialDate = new Date();
  var allUrls=[], allData = [];
  for(var i = 0; i<5;i++){
  var key = '8DCCE9C23F108A00F14E806BD21D8936';
  var interval = 'day';
  var start = new Date();
  start = new Date(start.setDate(initialDate.getDate()-i));
  var radiationUrl = 'https://api.pulseenergy.com/pulse/1/points/66094/data.json?key='+key+'&interval='+interval+'&start='+start.toISOString();
  var humidityUrl = 'https://api.pulseenergy.com/pulse/1/points/66095/data.json?key='+key+'&interval='+interval+'&start='+start.toISOString();
  var temperatureUrl = 'https://api.pulseenergy.com/pulse/1/points/66077/data.json?key='+key+'&interval='+interval+'&start='+start.toISOString();
  var windUrl = 'https://api.pulseenergy.com/pulse/1/points/66096/data.json?key='+key+'&interval='+interval+'&start='+start.toISOString();
  var powerUrl = 'https://api.pulseenergy.com/pulse/1/points/50578/data.json?key='+key+'&interval='+interval+'&start='+start.toISOString();
  var count = 0;
  
  allUrls.push(radiationUrl);
  allUrls.push(humidityUrl);
  allUrls.push(temperatureUrl);
  allUrls.push(windUrl);
  allUrls.push(powerUrl);
  }
  for(var i=0; i<allUrls.length; i++){
    console.log('URL: '+allUrls[i]);
    https.get(allUrls[i], function(res){
      var data = '';
      res.on('data', function(chunk){
        data += chunk;
      });
      res.on('end', function(){
        var obj = JSON.parse(data);
        var label = "";
        for(var i = 0;i<5;i++){
          var date = new Date(obj['start']);
          if(date.getDate() == initialDate.getDate() -i){
            label = obj['label'] +"%%%"+ i;
          }
        }
        allData.push({"label":label, "data":obj['data']});
        
        count++;
        if(count==25){
         applyMachineLearning(createSingleDataArray(allData),"pulse");
        }
      });
    }).on('error', function(e){
      console.error('machine_learning.pulseForecast(): ' +e);
    });
  }
}

var createSingleDataArray = function(allData){
  var radiationData, humidityData, temperatureData, windData, powerData;
  var j=0;
  var date;
  var singleDataArray=[];
  var obj = {};
  var normalizedData;
  var radiationDataArray = {};
  var humidityDataArray = {};
  var temperatureDataArray = {};
  var windDataArray = {};
  var powerDataArray = {};
  for(var i=0; i<allData.length; i++){
    if(allData[i].label.indexOf('Montreal Net Radiation - CWTA') != -1){
      var spliced = allData[i].label.split("%%%"); 
      radiationDataArray[spliced[1]] = allData[i].data; 
    }else if (allData[i].label.indexOf('Montreal Relative Humidity - CWTA') != -1){
      var spliced = allData[i].label.split("%%%"); 
      humidityDataArray[spliced[1]] = allData[i].data; 
    }else if(allData[i].label.indexOf('Montreal Temperature - CWTA') != -1){
      var spliced = allData[i].label.split("%%%"); 
      temperatureDataArray[spliced[1]] = allData[i].data; 
    }else if(allData[i].label.indexOf('Montreal Wind Speed - CWTA') != -1){
      var spliced = allData[i].label.split("%%%"); 
      windDataArray[spliced[1]] = allData[i].data; 
    }else if (allData[i].label.indexOf('Real Power Demand - Downtown Main Entrance') != -1){
      var spliced = allData[i].label.split("%%%"); 
      powerDataArray[spliced[1]] = allData[i].data; 
    }
  }
        var rad = radiationDataArray["0"].concat(radiationDataArray["1"],radiationDataArray["2"],radiationDataArray["3"],radiationDataArray["4"]);
        radiationData = rad;
        var hum = humidityDataArray["0"].concat(humidityDataArray["1"],humidityDataArray["2"],humidityDataArray["3"],humidityDataArray["4"]);
        humidityData = hum;
        var temp = temperatureDataArray["0"].concat(temperatureDataArray["1"],temperatureDataArray["2"],temperatureDataArray["3"],temperatureDataArray["4"]);
        temperatureData = temp;
        var wind = windDataArray["0"].concat(windDataArray["1"],windDataArray["2"],windDataArray["3"],windDataArray["4"]);
        windData = wind;
        var pow = powerDataArray["0"].concat(powerDataArray["1"],powerDataArray["2"],powerDataArray["3"],powerDataArray["4"]);
        powerData = pow;
  

  for(var i=0; i<powerData.length; i++){
    obj = {}
    obj.date = powerData[i][0];
    obj.seconds = new Date(obj.date).getTime()/1000;
    obj.power = powerData[i][1];

    //We expect the timestamps to be the same for the other columns.
    if(j<radiationData.length){
      if(obj.date == radiationData[j][0]){
        obj.radiation = radiationData[j][1];
        obj.humidity = humidityData[j][1];
        obj.temperature = temperatureData[j][1];
        obj.wind = windData[j][1];
        j++;
      }else if(j==0 && (new Date(obj.date) - new Date(radiationData[j][0]) > 0)){
        obj.radiation = '--';
        obj.humdity = '--';
        obj.temperature = '--';
        obj.wind = '--';
        j++;
      }else{
        obj.radiation = '--';
        obj.humdity = '--';
        obj.temperature = '--';
        obj.wind = '--';
      }
    }

    singleDataArray.push(obj);
  }
   return singleDataArray;
}

function applyMachineLearning(data,type){
  //Determine the min and max values for all of the parameters as 
  //this will be used later when normalizing the same.
  var minRadiation = 0, maxRadiation = 0,
      minHumidity = 0, maxHumidity = 0,
      minTemperature = 0, maxTemperature = 0,
      minWind = 0, maxWind = 0,
      minPower = 0, maxPower = 0; 
      
  for(var i=0; i<data.length; i++){
    if(data[i].radiation && data[i].radiation < minRadiation)
      minRadiation = data[i].radiation;

    if(data[i].radiation && data[i].radiation > maxRadiation)
      maxRadiation = data[i].radiation;

    if(data[i].humidity && data[i].humidity < minHumidity)
      minHumidity = data[i].humidity;  

    if(data[i].humidity && data[i].humidity > maxHumidity)
      maxHumidity = data[i].humidity;
    
    if(data[i].temperature && data[i].temperature < minTemperature)
      minTemperature = data[i].temperature;
    
    if(data[i].temperature && data[i].temperature > maxTemperature)
      maxTemperature = data[i].temperature
    
    if(data[i].wind && data[i].wind < minWind)
      minWind = data[i].wind;
    
    if(data[i].wind && data[i].wind > maxWind)
      maxWind = data[i].wind;
    
    if(data[i].power && data[i].power < minPower)
      minPower = data[i].power;
    
    if(data[i].power && data[i].power > maxPower)
      maxPower = data[i].power;
  }
  
  //Make sure all the input parameters for the training data are between 0 and 1.
  var input = {};
  var output = {};
  var normalizedData = [];
  var secondsInYear = 31622400; //Number of seconds in a leap year.
  var secondsInDay = 86400;

  for(var i=0; i<data.length; i++){
    input = {};
    output = {};
    
    input.date = (data[i].seconds % secondsInDay) / secondsInDay;
    if(data[i].radiation)
      input.radiation = (data[i].radiation + (maxRadiation - minRadiation))/(maxRadiation + maxRadiation - minRadiation);  
    if(data[i].humidity)
      input.humidity  = (data[i].humidity + (maxHumidity - minHumidity))/(maxHumidity + maxHumidity - minHumidity);
    if(data[i].temperature)
      input.temperature  = (data[i].temperature + (maxTemperature - minTemperature))/(maxTemperature + maxTemperature - minTemperature) ;
    if(data[i].wind)
      input.wind  = (data[i].wind + (maxWind - minWind))/(maxWind + maxWind - minWind);
    if(data[i].power)
      output.power  = (data[i].power + (maxPower - minPower))/(maxPower + maxPower - minPower);
    
    normalizedData.push({"input": input, "output": output}); 
  }

  //Generate forecast rows at 15 minute invervals for the next 64 hours.
  var lastDate = data[data.length-1].date;
  var datePlus15;
  var dateSeconds;
  var forecastData = [];
  var secondsToTime = {};

  for(var i = 0; i<64; i++){
    datePlus15 = new Date(lastDate);
    datePlus15.setMinutes(datePlus15.getMinutes() + ((i+1)*15));
    dateSeconds = datePlus15.getTime()/1000;
    forecastData.push({date: (dateSeconds % secondsInDay)/secondsInDay});
    secondsToTime[(dateSeconds % secondsInDay)/secondsInDay] = datePlus15;
  }
  
  //Train the data and run on the test data.
  var output;
  var finalDataArray = data;

  net.train(normalizedData);
  for(var i = 0; i<forecastData.length; i++){
    output = net.run(forecastData[i]);
    finalDataArray.push({
      "date": secondsToTime[forecastData[i].date], 
      "radiation": '--',
      "humidity": '--',
      "temperature": '--',
      "wind": '--',
      "power":  output.power*(maxPower+maxPower-minPower)-(maxPower-minPower)
    });
  }
  if(type == "pulse"){
    server.pulseClientData(finalDataArray);
  }
  console.log(finalDataArray);
}

exports.brainTest = function(){
  net.train([
             {input: { r: 0.03, g: 0.7, b: 0.5 }, output: { black: 1 }},
             {input: { r: 0.16, g: 0.09, b: 0.2 }, output: { white: 1 }},
             {input: { r: 0.5, g: 0.5}, output: { white: 1 }}
            ]);

  var output = net.run({ r: 1, g: 0.4 });  // { white: 0.99, black: 0.002 }
  console.log(output);
}
