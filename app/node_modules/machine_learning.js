var brain = require('brain')
  , https = require('https');

var net = new brain.NeuralNetwork({learningRate:0});
 
exports.pulseForecast = function(){
  var key = '8DCCE9C23F108A00F14E806BD21D8936';
  var interval = 'month';
  var start = '2013-11-05T08:15:30-05:00';
  var radiationUrl = 'https://api.pulseenergy.com/pulse/1/points/66094/data.json?key='+key+'&interval='+interval;
  var humidityUrl = 'https://api.pulseenergy.com/pulse/1/points/66095/data.json?key='+key+'&interval='+interval;
  var temperatureUrl = 'https://api.pulseenergy.com/pulse/1/points/66077/data.json?key='+key+'&interval='+interval;
  var windUrl = 'https://api.pulseenergy.com/pulse/1/points/66096/data.json?key='+key+'&interval='+interval;
  var powerUrl = 'https://api.pulseenergy.com/pulse/1/points/50578/data.json?key='+key+'&interval='+interval;
  var allUrls=[], allData = [];
  var count = 0;
  
  allUrls.push(radiationUrl);
  allUrls.push(humidityUrl);
  allUrls.push(temperatureUrl);
  allUrls.push(windUrl);
  allUrls.push(powerUrl);

  for(var i=0; i<allUrls.length; i++){
    console.log('URL: '+allUrls[i]);
    https.get(allUrls[i], function(res){
      res.on('data', function(chunk){
        var obj = JSON.parse(chunk);
        allData.push({"label":obj['label'], "data":obj['data']});
        count++;
        if(count==5){
          createSingleDataArray(allData);
        }
      });
    }).on('error', function(e){
      console.error('machine_learning.pulseForecast(): ' +e);
    });
  }
}

var createSingleDataArray = function(allData){
  var radiationData, humidityData, temperatureData, windData, powerData;
  var j=0;
  var date;
  var singleDataArray=[];
  var obj = {};
  var normalizedData;

  for(var i=0; i<allData.length; i++){
    switch(allData[i].label){
      case 'Montreal Net Radiation - CWTA':
        radiationData = allData[i].data;
        break;
      case 'Montreal Relative Humidity - CWTA':
        humidityData = allData[i].data;
        break;
      case 'Montreal Temperature - CWTA':
        temperatureData = allData[i].data;
        break;
      case 'Montreal Wind Speed - CWTA':
        windData = allData[i].data;
        break;
      case 'Real Power Demand - Downtown Main Entrance':
        powerData = allData[i].data;
        break;
      default:
        break;
    }
  }

  for(var i=0; i<powerData.length; i++){
    obj = {}
    obj.date = powerData[i][0];
    obj.seconds = new Date(obj.date).getTime()/1000;
    obj.power = powerData[i][1];

    //We expect the timestamps to be the same for the other columns.
    if(j<radiationData.length){
      if(obj.date == radiationData[j][0]){
        obj.radiation = radiationData[j][1];
        obj.humidity = humidityData[j][1];
        obj.temperature = temperatureData[j][1];
        obj.wind = windData[j][1];
        j++;
      }else if(j==0 && (new Date(obj.date) - new Date(radiationData[j][0]) > 0)){
        j++;
      }
    }

    singleDataArray.push(obj);
  }

   applyMachineLearning(singleDataArray);
}

function applyMachineLearning(data){
  //Determine the min and max values for all of the parameters as 
  //this will be used later when normalizing the same.
  var minRadiation = 0, maxRadiation = 0,
      minHumidity = 0, maxHumidity = 0,
      minTemperature = 0, maxTemperature = 0,
      minWind = 0, maxWind = 0,
      minPower = 0, maxPower = 0; 
      
  for(var i=0; i<data.length; i++){
    if(data[i].radiation && data[i].radiation < minRadiation)
      minRadiation = data[i].radiation;

    if(data[i].radiation && data[i].radiation > maxRadiation)
      maxRadiation = data[i].radiation;

    if(data[i].humidity && data[i].humidity < minHumidity)
      minHumidity = data[i].humidity;  

    if(data[i].humidity && data[i].humidity > maxHumidity)
      maxHumidity = data[i].humidity;
    
    if(data[i].temperature && data[i].temperature < minTemperature)
      minTemperature = data[i].temperature;
    
    if(data[i].temperature && data[i].temperature > maxTemperature)
      maxTemperature = data[i].temperature
    
    if(data[i].wind && data[i].wind < minWind)
      minWind = data[i].wind;
    
    if(data[i].wind && data[i].wind > maxWind)
      maxWind = data[i].wind;
    
    if(data[i].power && data[i].power < minPower)
      minPower = data[i].power;
    
    if(data[i].power && data[i].power > maxPower)
      maxPower = data[i].power;
  }
  
  //Make sure all the input parameters for the training data are between 0 and 1.
  var input = {};
  var output = {};
  var normalizedData = [];
  var secondsInYear = 31622400; //Number of seconds in a leap year.
  var secondsInDay = 86400;

  for(var i=0; i<data.length; i++){
    input = {};
    output = {};
    
    input.date = (data[i].seconds % secondsInDay) / secondsInDay;
    if(data[i].radiation)
      input.radiation = (data[i].radiation + (maxRadiation - minRadiation))/(maxRadiation + maxRadiation - minRadiation);  
    if(data[i].humidity)
      input.humidity  = (data[i].humidity + (maxHumidity - minHumidity))/(maxHumidity + maxHumidity - minHumidity);
    if(data[i].temperature)
      input.temperature  = (data[i].temperature + (maxTemperature - minTemperature))/(maxTemperature + maxTemperature - minTemperature) ;
    if(data[i].wind)
      input.wind  = (data[i].wind + (maxWind - minWind))/(maxWind + maxWind - minWind);
    if(data[i].power)
      output.power  = (data[i].power + (maxPower - minPower))/(maxPower + maxPower - minPower);
    
    normalizedData.push({"input": input, "output": output}); 
  }

  //Generate forecast rows at 15 minute invervals for the next 64 hours.
  var lastDate = data[data.length-1].date;
  var datePlus15;
  var dateSeconds;
  var forecastData = [];
  var secondsToTime = {};

  for(var i = 0; i<64; i++){
    datePlus15 = new Date(lastDate);
    datePlus15.setMinutes(datePlus15.getMinutes() + ((i+1)*15));
    dateSeconds = datePlus15.getTime()/1000;
    forecastData.push({date: (dateSeconds % secondsInDay)/secondsInDay});
    secondsToTime[(dateSeconds % secondsInDay)/secondsInDay] = datePlus15;
  }
  
  //Train the data and run on the test data.
  var output;
  var finalDataArray = data;

  net.train(normalizedData,{errorTresh: 0.000001, iterations: 500000});
  for(var i = 0; i<forecastData.length; i++){
    output = net.run(forecastData[i]);
    finalDataArray.push({
      "date": secondsToTime[forecastData[i].date], 
      "radiation": '--',
      "humidity": '--',
      "temperature": '--',
      "wind": '--',
      "power":  output.power*(maxPower+maxPower-minPower)-(maxPower-minPower)
    });
  }
  console.log(finalDataArray);
}

exports.brainTest = function(){
  net.train([
             {input: { r: 0.03, g: 0.7, b: 0.5 }, output: { black: 1 }},
             {input: { r: 0.16, g: 0.09, b: 0.2 }, output: { white: 1 }},
             {input: { r: 0.5, g: 0.5}, output: { white: 1 }}
            ]);

  var output = net.run({ r: 1, g: 0.4 });  // { white: 0.99, black: 0.002 }
  console.log(output);
}
