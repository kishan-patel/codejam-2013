var brain = require('brain')
  , https = require('https')
  , server = require('./server.js');

var net = new brain.NeuralNetwork({learningRate:0});
 
exports.pulseForecast = function(){
  var key = '8DCCE9C23F108A00F14E806BD21D8936';
  var interval = 'month';
  var start = '2013-11-05T08:15:30-05:00';
  var radiationUrl = 'https://api.pulseenergy.com/pulse/1/points/66094/data.json?key='+key+'&interval='+interval;
  var humidityUrl = 'https://api.pulseenergy.com/pulse/1/points/66095/data.json?key='+key+'&interval='+interval;
  var temperatureUrl = 'https://api.pulseenergy.com/pulse/1/points/66077/data.json?key='+key+'&interval='+interval;
  var windUrl = 'https://api.pulseenergy.com/pulse/1/points/66096/data.json?key='+key+'&interval='+interval;
  var powerUrl = 'https://api.pulseenergy.com/pulse/1/points/50578/data.json?key='+key+'&interval='+interval;
  var allUrls=[], allData = [];
  var count = 0;
  
  allUrls.push(radiationUrl);
  allUrls.push(humidityUrl);
  allUrls.push(temperatureUrl);
  allUrls.push(windUrl);
  allUrls.push(powerUrl);

  for(var i=0; i<allUrls.length; i++){
    console.log('URL: '+allUrls[i]);
    https.get(allUrls[i], function(res){
      var data = '';
      res.on('data', function(chunk){
        data += chunk;
      });
      res.on('end', function(){
        var obj = JSON.parse(data);
        allData.push({"label":obj['label'], "data":obj['data']});
        count++;
        if(count==5){
         applyMachineLearning(createSingleDataArray(allData),"pulse");
        }
      });
    }).on('error', function(e){
      console.error('machine_learning.pulseForecast(): ' +e);
    });
  }
}

exports.csvForecast = function(data, type){
    return applyMachineLearning(data, type);
}

var createSingleDataArray = function(allData){
  var radiationData, humidityData, temperatureData, windData, powerData;
  var j=0;
  var date;
  var singleDataArray=[];
  var obj = {};
  var normalizedData;

  for(var i=0; i<allData.length; i++){
    switch(allData[i].label){
      case 'Montreal Net Radiation - CWTA':
        radiationData = allData[i].data;
        break;
      case 'Montreal Relative Humidity - CWTA':
        humidityData = allData[i].data;
        break;
      case 'Montreal Temperature - CWTA':
        temperatureData = allData[i].data;
        break;
      case 'Montreal Wind Speed - CWTA':
        windData = allData[i].data;
        break;
      case 'Real Power Demand - Downtown Main Entrance':
        powerData = allData[i].data;
        break;
      default:
        break;
    }
  }

  for(var i=0; i<powerData.length; i++){
    obj = {}
    obj.date = powerData[i][0];
    obj.seconds = new Date(obj.date).getTime()/1000;
    obj.power = powerData[i][1];

    //We expect the timestamps to be the same for the other columns.
    if(j<radiationData.length){
      if(obj.date == radiationData[j][0]){
        obj.radiation = radiationData[j][1];
        obj.humidity = humidityData[j][1];
        obj.temperature = temperatureData[j][1];
        obj.wind = windData[j][1];
        j++;
      }else if(j==0 && (new Date(obj.date) - new Date(radiationData[j][0]) > 0)){
        obj.radiation = '--';
        obj.humidity = '--';
        obj.temperature = '--';
        obj.wind = '--';
        j++;
      }else{
        obj.radiation = '--';
        obj.humidity = '--';
        obj.temperature = '--';
        obj.wind = '--';
      }
    }

    singleDataArray.push(obj);
  }
   return singleDataArray;
}

function applyMachineLearning(data, type){
  //If we are trying to apply the machine learning to the data from the 
  //csv file, then it already contains predictions for weather, temperature etc.
  //so we need to include this when applying machine learning.
  var splitData=[], futureData=[], arrays=[];
  if(type == "csv"){
    splitData = splitPastandFuture(data);
    data = splitData["past"];
    futureData = splitData["future"];
    arrays.push(data);
    arrays.push(futureData);
  }else{
    arrays.push(data);
  }
  
  //Determine the min and max values for all of the parameters as 
  //this will be used later when normalizing the same.
  var minAndMaxes = determineMaxAndMin(arrays);
  var minRadiation = minAndMaxes['minRadiation'];
  var maxRadiation = minAndMaxes['maxRadiation'];
  var minHumidity = minAndMaxes['minHumidity']; 
  var maxHumidity = minAndMaxes['maxHumidity'];
  var minTemperature = minAndMaxes['minTemperature'];
  var maxTemperature = minAndMaxes['maxTemperature'];
  var minWind = minAndMaxes['minWind']; 
  var maxWind = minAndMaxes['maxWind'];
  var minPower = minAndMaxes['minPower']; 
  var maxPower = minAndMaxes['maxPower']; 
  
  
  //Make sure all the input parameters for the training data are between 0 and 1.
  var input = {};
  var output = {};
  var normalizedData = [];
  var secondsInYear = 31622400; //Number of seconds in a leap year.
  var secondsInDay = 86400;

  for(var i=0; i<data.length; i++){
    input = {};
    output = {};
    
    input.date = type == 'csv' ? new Date(data[i].date).getTime() / 1000 : (data[i].seconds % secondsInDay) / secondsInDay;
    if(!isNaN(data[i].radiation))
      input.radiation = (data[i].radiation + (maxRadiation - minRadiation))/(maxRadiation + maxRadiation - minRadiation);  
    if(!isNaN(data[i].humidity))
      input.humidity  = (data[i].humidity + (maxHumidity - minHumidity))/(maxHumidity + maxHumidity - minHumidity);
    if(!isNaN(data[i].temperature))
      input.temperature  = (data[i].temperature + (maxTemperature - minTemperature))/(maxTemperature + maxTemperature - minTemperature);
    if(!isNaN(data[i].wind))
      input.wind  = (data[i].wind + (maxWind - minWind))/(maxWind + maxWind - minWind);
    if(!isNaN(data[i].power))
      output.power  = (data[i].power + (maxPower - minPower))/(maxPower + maxPower - minPower);
    
    normalizedData.push({"input": input, "output": output}); 
  }

  //Generate forecast rows at 15 minute invervals for the next 16 hours. For data from the csv file,
  //we already have some forecasted values for weather, temperature etc. so we reuse these.
  //If this is not the case, we have to generate 64 rows.
  if(type == "csv"){
    var forecastObj = {};
    var forecastData = [];

    for(var i=0; i<futureData.length; i++){
      forecastObj = {};
      forecastObj.date = ((new Date(futureData[i].date).getTime() / 1000) % secondsInDay) / secondsInDay;

      if(!isNaN(futureData[i].radiation))
        forecastObj.radiation = (futureData[i].radiation + (maxRadiation - minRadiation))/(maxRadiation + maxRadiation - minRadiation);
      if(!isNaN(futureData[i].humidity)) 
        forecastObj.humidity = (futureData[i].humidity + (maxHumidity - minHumidity))/(maxHumidity + maxHumidity - minHumidity);
      if(!isNaN(futureData[i].temperature))
        forecastObj.temperature = (futureData[i].temperature + (maxTemperature - minTemperature))/(maxTemperature + maxTemperature - minTemperature);
      if(!isNaN(futureData[i].wind))
        forecastObj.wind = (futureData[i].wind + (maxWind - minWind))/(maxWind + maxWind - minWind);

      forecastData.push(forecastObj);
    }
  }else{
    var lastDate = data[data.length-1].date;
    var datePlus15;
    var dateSeconds;
    var secondsToTime = {};
    var forecastData = [];

    for(var i = 0; i<64; i++){
      datePlus15 = new Date(lastDate);
      datePlus15.setMinutes(datePlus15.getMinutes() + ((i+1)*15));
      dateSeconds = datePlus15.getTime()/1000;
      forecastData.push({date: (dateSeconds % secondsInDay)/secondsInDay});
      secondsToTime[(dateSeconds % secondsInDay)/secondsInDay] = datePlus15;
    }
  }
  
  //Train the data and run on the test data.
  var output;
  var finalDataArray = data;

  net.train(normalizedData,{errorTresh: 0.000001, iterations: 500000});
  for(var i = 0; i<forecastData.length; i++){
    output = net.run(forecastData[i]);
    finalDataArray.push({
      "date": type == "csv" ? futureData[i].date : secondsToTime[forecastData[i].date], 
      "radiation": type == "csv" ? (!isNaN(futureData[i].radiation) ? futureData[i].radiation : '--') : '--',
      "humidity": type == "csv" ? (!isNaN(futureData[i].humidity) ? futureData[i].humidity : '--') : '--',
      "temperature": type == "csv" ? (!isNaN(futureData[i].temperature) ? futureData[i].temperature : '--') : '--',
      "wind": type == "csv" ? (!isNaN(futureData[i].temperature) ? futureData[i].temperature : '--') : '--',
      "power":  output.power*(maxPower+maxPower-minPower)-(maxPower-minPower)
    });
  }
  if(type == "pulse"){
    server.pulseClientData(finalDataArray);
  }else if(type == "csv"){
    return finalDataArray;
  }
  console.log(finalDataArray);
}

function splitPastandFuture(data){
  var slicedArr = {};
  for(var i=0; i<data.length; i++){
    if(isNaN(data[i].power)){
      slicedArr.past = data.splice(0,i);
      slicedArr.future = data.splice(i);  
      break;
    }
  }
  return slicedArr;
}

function determineMaxAndMin(arrays){
  var data;
  var minRadiation = 0, maxRadiation = 0,
      minHumidity = 0, maxHumidity = 0,
      minTemperature = 0, maxTemperature = 0,
      minWind = 0, maxWind = 0,
      minPower = 0, maxPower = 0;

  for(var j=0; j<arrays.length; j++){
    data = arrays[j];

    for(var i=0; i<data.length; i++){
      if(!isNaN(data[i].radiation) && data[i].radiation < minRadiation)
        minRadiation = data[i].radiation;

      if(!isNaN(data[i].radiation) && data[i].radiation > maxRadiation)
        maxRadiation = data[i].radiation;

      if(!isNaN(data[i].humidity) && data[i].humidity < minHumidity)
        minHumidity = data[i].humidity;

      if(!isNaN(data[i].humidity) && data[i].humidity > maxHumidity)
        maxHumidity = data[i].humidity;

      if(!isNaN(data[i].temperature) && data[i].temperature < minTemperature)
        minTemperature = data[i].temperature;

      if(!isNaN(data[i].temperature) && data[i].temperature > maxTemperature)
        maxTemperature = data[i].temperature

      if(!isNaN(data[i].wind) && data[i].wind < minWind)
        minWind = data[i].wind;

      if(!isNaN(data[i].wind) && data[i].wind > maxWind)
        maxWind = data[i].wind;

      if(!isNaN(data[i].power) && data[i].power < minPower)
        minPower = data[i].power;

      if(!isNaN(data[i].power) && data[i].power > maxPower)
        maxPower = data[i].power;
    }
  }

  return {
    'minRadiation': minRadiation, 
    'maxRadiation': maxRadiation, 
    'minHumidity': minHumidity,
    'maxHumidity': maxHumidity,
    'minTemperature': minTemperature,
    'maxTemperature': maxTemperature,
    'minWind': minWind,
    'maxWind': maxWind,
    'minPower': minPower,
    'maxPower': maxPower
  }
}

exports.brainTest = function(){
  net.train([
             {input: { r: 0.03, g: 0.7, b: 0.5 }, output: { black: 1 }},
             {input: { r: 0.16, g: 0.09, b: 0.2 }, output: { white: 1 }},
             {input: { r: 0.5, g: 0.5}, output: { white: 1 }}
            ]);

  var output = net.run({ r: 1, g: 0.4 });  // { white: 0.99, black: 0.002 }
  console.log(output);
}
